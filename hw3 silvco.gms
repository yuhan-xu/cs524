$title hw3 silvco

* create a set of grades
Set grades/defective,grade1,grade2,grade3,grade4/;

* create a set J consisting of methods
Set J/method1,method2/;

* create a table called melt with grades and methods
table melt(grades,J)
            method1    method2
defective   30         20
grade1      30         20
grade2      20         25
grade3      15         20
grade4      5          15;

* create a table called refire with grades
table refire(grades,grades)
             defective  grade1  grade2  grade3  grade4
defective    30         25      15      20      10
grade1       0          30      30      20      20
grade2       0          0       40      30      30
grade3       0          0       0       50      50
grade4       0          0       0       0       100;

positive variables numberMelted(J),
                   numberAfterMelting(grades),
                   numberRefired(grades),
                   numberAfterRefiring(grades);

free variable totcost "total cost of germanium processing required to meet the demands";

* create an alias that uses g to represent grades
alias(grades,g);
                   
parameters demand(grades)"demand of each grade",methodsCosts(J)"cost of using each method"
  demand(grades)/"defective" 0,"grade1" 3000,"grade2" 3000,"grade3" 2000,"grade4" 1000/,
  methodsCosts(J)/"method1" 50,"method2" 70/;
  
scalar costToRefirePerTransistor, maxNumberOfTransistorToMeltAndRefire
  costToRefirePerTransistor/25/,
  maxNumberOfTransistorToMeltAndRefire/20000/;
  
* VARIBLE BOUNDS  
numberRefired.lo("grade4") = 0;
numberRefired.up("grade4") = 0;
  
equations transistorLimit   "the amount of germanium that are melted and refired should be less than maximum number of transistor to melt and refire"
          demandLimit(grades) "after the process of melting and refiring, the amount of each grade should be greater than or equal to the demand of that grade"
          beforeAndAfterMeltBalance(grades) "the amount of each grade generated by melting should equal to numberAfterMelting for each grade"
          beforeAndAfterRefireBalance(grades) "the amount of each grade generated by refiring should equal to numberAfterRefiring for each grade"
          afterMeltingAndRefireMatching(grades) "for each grade, numberRefired should be less than or equal to numberAfterMelting"
          objfunc;
    
* EQUATION (MODEL) DEFINITION      
transistorLimit..
  sum(J,numberMelted(J)) + sum(grades,numberRefired(grades)) =l= maxNumberOfTransistorToMeltAndRefire;

demandLimit(grades)..
  numberAfterMelting(grades) - numberRefired(grades) + numberAfterRefiring(grades) =g= demand(grades);
  
beforeAndAfterMeltBalance(grades)..
  sum(J,numberMelted(J)*(melt(grades,J)/100)) =e= numberAfterMelting(grades);

beforeAndAfterRefireBalance(grades)..
  sum(g,numberRefired(g)*(refire(g,grades)/100)) =e= numberAfterRefiring(grades);
  
afterMeltingAndRefireMatching(grades)..
  numberRefired(grades) =l= numberAfterMelting(grades);
  
* Objective function  
objfunc..
  totcost =e= sum(J,methodsCosts(J)*numberMelted(J)) + costToRefirePerTransistor*sum(grades,numberRefired(grades));
  
model silvco /all/;
solve silvco using lp min totcost;

numberMelted.l(J) = round(numberMelted.l(J));
numberAfterMelting.l(grades) = round(numberAfterMelting.l(grades));
numberRefired.l(grades) = round(numberRefired.l(grades));
numberAfterRefiring.l(grades) = round(numberAfterRefiring.l(grades));